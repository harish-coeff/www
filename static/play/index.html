<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ShapeShift Runner</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #2c2c2c; /* Darker gray for body */
            font-family: 'Press Start 2P', monospace;
            color: white;
            overflow: hidden; /* Prevent scrolling on mobile */
        }
        canvas {
            background-color: #000000; /* Solid dark background for canvas */
            display: block;
            border: 3px solid #ffffff;
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
            cursor: pointer; /* Indicate canvas is interactive */
            max-width: 100%; /* Ensure canvas scales down on small screens */
            max-height: 100vh; /* Allow canvas to take full height if needed */
            object-fit: contain; /* Maintain aspect ratio if scaling */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Canvas and Context Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // --- Game Constants ---
        const PLAYER_X = 100; // Player's fixed X position
        const PLAYER_Y = CANVAS_HEIGHT / 2; // Player's fixed Y position (vertical center)
        const PLAYER_SIZE = 50; // Characteristic size (diameter, side length)
        const WALL_WIDTH = 80; // Width of the walls
        const SHAPES = ['circle', 'square', 'triangle'];
        let currentShapeIndex = 0; // To cycle through shapes

        // --- Game State Variables ---
        let playerShape; // Current shape of the player
        let walls; // Array to store wall objects { x, holeShape, scored }
        let wallSpeed; // Current speed of walls in pixels/second
        let spawnInterval; // Current interval between wall spawns in seconds
        let timeSinceLastSpawn;
        let score;
        let elapsedSec; // Total elapsed time for difficulty scaling
        let gameOver;
        let animationFrameId;
        let lastTime; // For delta time calculation

        // --- Initialization ---
        function init() {
            // Event Listeners for player controls
            window.addEventListener('keydown', handleKeyboardInput);
            canvas.addEventListener('click', handleCanvasTap); // For mouse clicks and touch taps
            resetGame();
        }

        // --- Reset Game State ---
        function resetGame() {
            currentShapeIndex = 0; // Reset to circle
            playerShape = SHAPES[currentShapeIndex];
            walls = [];
            score = 0;
            elapsedSec = 0;
            wallSpeed = 200; // Initial wall speed
            spawnInterval = 1.5; // Initial spawn interval
            timeSinceLastSpawn = spawnInterval; // Spawn first wall quickly
            gameOver = false;

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            lastTime = performance.now();
            gameLoop(lastTime);
        }

        // --- Keyboard Input Handling ---
        function handleKeyboardInput(e) {
            if (gameOver) {
                if (e.key === 'r' || e.key === 'R') {
                    resetGame();
                }
                return;
            }

            if (e.key === '1') {
                playerShape = 'circle';
                currentShapeIndex = SHAPES.indexOf('circle');
            } else if (e.key === '2') {
                playerShape = 'square';
                currentShapeIndex = SHAPES.indexOf('square');
            } else if (e.key === '3') {
                playerShape = 'triangle';
                currentShapeIndex = SHAPES.indexOf('triangle');
            }
        }

        // --- Canvas Tap Handling (for mobile and mouse) ---
        function handleCanvasTap() {
            if (gameOver) {
                resetGame();
            } else {
                // Cycle to the next shape
                currentShapeIndex = (currentShapeIndex + 1) % SHAPES.length;
                playerShape = SHAPES[currentShapeIndex];
            }
        }

        // --- Wall Spawning ---
        function spawnWall() {
            const randomShapeIndex = Math.floor(Math.random() * SHAPES.length);
            const holeShape = SHAPES[randomShapeIndex];
            walls.push({
                x: CANVAS_WIDTH, // Spawn at the right edge of the canvas
                holeShape: holeShape,
                scored: false
            });
        }

        // --- Update Game Logic (called each frame) ---
        function update(dt) {
            if (gameOver) return;

            elapsedSec += dt;

            // Continuous difficulty increase
            wallSpeed = 200 + 20 * elapsedSec;
            spawnInterval = Math.max(1.5 - 0.02 * elapsedSec, 0.4);

            // Spawn new walls
            timeSinceLastSpawn += dt;
            if (timeSinceLastSpawn >= spawnInterval) {
                spawnWall();
                timeSinceLastSpawn = 0;
            }

            // Move walls and check for collisions/scoring
            for (let i = walls.length - 1; i >= 0; i--) {
                const wall = walls[i];
                const wallOldX = wall.x; // Wall's x position BEFORE this frame's movement

                wall.x -= wallSpeed * dt; // Update wall's x position (new position)

                // Scoring: Increment score when wall's right edge passes player's X position
                if (!wall.scored && (wall.x + WALL_WIDTH) < PLAYER_X) {
                    score++;
                    wall.scored = true;
                }

                // Collision Detection (using swept area)
                const playerLeft = PLAYER_X - PLAYER_SIZE / 2;
                const playerRight = PLAYER_X + PLAYER_SIZE / 2;

                const wallSweptLeft = wall.x;
                const wallSweptRight = wallOldX + WALL_WIDTH;

                if (playerRight > wallSweptLeft && playerLeft < wallSweptRight) {
                    if (playerShape !== wall.holeShape) {
                        gameOver = true;
                        return;
                    }
                }

                // Remove off-screen walls
                if (wall.x + WALL_WIDTH < 0) {
                    walls.splice(i, 1);
                }
            }
        }

        // --- Drawing Functions ---
        function drawPlayer(ctx) {
            ctx.fillStyle = '#00FF00'; // Bright green for player
            ctx.beginPath();
            const S = PLAYER_SIZE;

            if (playerShape === 'circle') {
                ctx.arc(PLAYER_X, PLAYER_Y, S / 2, 0, Math.PI * 2);
            } else if (playerShape === 'square') {
                ctx.rect(PLAYER_X - S / 2, PLAYER_Y - S / 2, S, S);
            } else if (playerShape === 'triangle') {
                const h = (Math.sqrt(3) / 2) * S;
                ctx.moveTo(PLAYER_X, PLAYER_Y - (2/3) * h);
                ctx.lineTo(PLAYER_X - S / 2, PLAYER_Y + (1/3) * h);
                ctx.lineTo(PLAYER_X + S / 2, PLAYER_Y + (1/3) * h);
            }
            ctx.closePath();
            ctx.fill();
        }

        function drawWall(ctx, wall) {
            ctx.fillStyle = '#888888';
            ctx.fillRect(wall.x, 0, WALL_WIDTH, CANVAS_HEIGHT);

            ctx.save();
            ctx.globalCompositeOperation = 'destination-out';
            
            ctx.beginPath();
            const holeX = wall.x + WALL_WIDTH / 2;
            const holeY = PLAYER_Y;
            const S = PLAYER_SIZE;

            if (wall.holeShape === 'circle') {
                ctx.arc(holeX, holeY, S / 2, 0, Math.PI * 2);
            } else if (wall.holeShape === 'square') {
                ctx.rect(holeX - S / 2, holeY - S / 2, S, S);
            } else if (wall.holeShape === 'triangle') {
                const h = (Math.sqrt(3) / 2) * S;
                ctx.moveTo(holeX, holeY - (2/3) * h);
                ctx.lineTo(holeX - S / 2, holeY + (1/3) * h);
                ctx.lineTo(holeX + S / 2, holeY + (1/3) * h);
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        function draw(ctx) {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            drawPlayer(ctx);
            walls.forEach(wall => drawWall(ctx, wall));

            ctx.fillStyle = 'white';
            ctx.font = '24px "Press Start 2P"';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText('Score: ' + score, 20, 20);

            ctx.font = '16px "Press Start 2P"';
            ctx.textAlign = 'right';
            // Restored detailed key mapping alongside tap instruction
            ctx.fillText('Tap | 1:Circle 2:Square 3:Triangle', CANVAS_WIDTH - 20, 20);


            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                ctx.font = '48px "Press Start 2P"';
                ctx.fillText('GAME OVER', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 60);

                ctx.font = '32px "Press Start 2P"';
                ctx.fillText('Final Score: ' + score, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);

                ctx.font = '24px "Press Start 2P"';
                // Updated restart instruction
                ctx.fillText('Tap or Press R to Restart', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 60);
            }
        }

        // --- Main Game Loop ---
        function gameLoop(timestamp) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            if (!gameOver) {
                update(dt);
            }
            draw(ctx);

            if (!gameOver) {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        // --- Start the Game ---
        init();
    </script>
</body>
</html>
